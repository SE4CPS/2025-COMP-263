<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Lab 1 – IndexedDB AgricultureDB (Mallineni 5708)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        max-width: 900px;
        margin: 24px auto;
        line-height: 1.5;
        padding: 0 16px;
      }
      h1,
      h2,
      h3 {
        line-height: 1.2;
        margin: 16px 0 8px;
      }
      code,
      kbd,
      pre {
        font-family: ui-monospace, Consolas, Menlo, monospace;
      }
      pre {
        background: #0b1020;
        color: #d2e3ff;
        padding: 12px;
        border-radius: 12px;
        overflow: auto;
      }
      .tag {
        display: inline-block;
        background: rgb(43, 43, 95);
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid #ccd;
      }
      .ok {
        color: #0a7a0a;
      }
      .warn {
        color: #a06b00;
      }
      .shot {
        border: 1px dashed #aaa;
        border-radius: 10px;
        padding: 10px;
        margin: 12px 0;
        background: #f8f8f8;
      }
      li {
        margin: 6px 0;
      }
    </style>
  </head>
  <body>
    <h1>Lab 1 – IndexedDB AgricultureDB</h1>
    <p>
      <b>Student:</b> <span class="tag">Sathwik Mallineni</span> &nbsp;
      <b>ID last four:</b> <span class="tag">5708</span>
    </p>

    <h2>Objective</h2>
    <p>
      Use <b>IndexedDB</b> (a key–value, offline-first browser database) to
      store heterogeneous agricultural data and verify storage/retrieval with
      console output and unit tests.
    </p>

    <h2>Database & Object Store</h2>
    <ul>
      <li><b>Database name:</b> <code>AgricultureDB</code></li>
      <li>
        <b>Object store:</b> <code>FarmData</code> with
        <code>{ keyPath: 'id', autoIncrement: true }</code>
      </li>
      <li>
        <b>Index:</b> optional on <code>timestamp</code> for time-based queries
      </li>
    </ul>

    <h2>Record Schema (per rubric)</h2>
    <pre>
// Example record written to FarmData
{
  id: &lt;auto&gt;,                          // primary key (auto-increment)
  sensorReadings: [12.1, 44.5, ...],   // Array of Numbers
  cropPhoto: "images/corn.jpg",        // String: local image URL (or data URL fallback)
  farmerNote: "Soil moisture low",     // String: unstructured text
  gpsCoordinates: 37.333451,           // Number (latitude stored as example)
  timestamp: Date("2025-09-05T12:34Z") // Date object
}</pre
    >

    <h2>How I Implemented It</h2>
    <ol>
      <li>
        <b>Create/Open DB</b> using
        <code>indexedDB.open('AgricultureDB', 1)</code>.
      </li>
      <li>
        <b>onupgradeneeded</b>: create <code>FarmData</code> with auto-increment
        key; create an index on <code>timestamp</code>.
      </li>
      <li>
        <b>Insert 10,000 rows</b> in batches with a single read–write
        transaction per batch to keep the UI responsive.
      </li>
      <li>
        <b>Retrieve</b> sample records using <code>getAll()</code> and count
        with <code>store.count()</code>.
      </li>
      <li>
        <b>Display</b> results via <code>console.table()</code> and a log area
        in the page.
      </li>
      <li>
        <b>Unit tests</b> via <code>console.assert()</code> to validate types
        and total row count.
      </li>
    </ol>

    <h2>Run Instructions</h2>
    <ol>
      <li>
        Serve the folder (VS Code <i>Live Server</i> or
        <code>python -m http.server 5500</code>).
      </li>
      <li>
        Open <code>http://localhost:5500/</code> → Click buttons in order:
        <ol>
          <li>① Init DB</li>
          <li>② Add 10,000 records</li>
          <li>③ Count + sample fetch</li>
          <li>④ Run unit tests</li>
        </ol>
      </li>
      <li>
        Open DevTools → <b>Application → IndexedDB</b> to inspect the store.
      </li>
    </ol>

    <h2>Notes / Troubleshooting</h2>
    <ul>
      <li>
        If tests say “found &gt; 10000 rows”, clear previous data: DevTools →
        Application → Storage → <b>Clear site data</b> and reseed.
      </li>
      <li>
        If images don’t appear, ensure the <code>images/</code> filenames match
        the paths in code. A data‑URL fallback is used otherwise.
      </li>
      <li>
        Always run from <code>http://localhost</code> (not <code>file://</code>)
        so IndexedDB origin behaves correctly.
      </li>
    </ul>

    <h2>Unit Test Examples</h2>
    <p>
      We used <code>console.assert()</code> tests. Example: validate image
      filenames end with common extensions.
    </p>
    <pre>
// Example image-name test
const IMG_RE = /\.(jpg|jpeg|png|webp|gif)$/i;
async function test_photoExtension() {
  const db = await openDB();
  const tx = db.transaction('FarmData', 'readonly');
  const req = tx.objectStore('FarmData').getAll(undefined, 50);
  const rows = await new Promise((res, rej) => {
    req.onsuccess = () => res(req.result || []);
    tx.onerror = () => rej(tx.error);
  });
  db.close();
  const ok = rows.every(r => typeof r.cropPhoto === 'string' &&
    (r.cropPhoto.startsWith('data:image/') || IMG_RE.test(r.cropPhoto)));
  console.assert(ok, 'cropPhoto should be a data URL or end with a common image extension');
}</pre
    >

    <p class="warn">
      This file is for documentation only; the actual app logic lives in
      <code>index.html</code>, <code>app.js</code>, and <code>tests.js</code>.
    </p>
  </body>
</html>
