<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lab 1 – IndexedDB</title>
</head>
<body>
  <h1>Lab 1 – IndexedDB</h1>

<script>
(async () => {
    const DB_NAME = 'AgricultureDB';
    const STORE   = 'FarmData';
    const VERSION = 1;
    const TOTAL   = 10000;
    const BATCH   = 500;

    function test(name, condition) {
        if (condition) {
        console.log(`%c${name} passed`, "color: #0a7f00; font-weight:600");
        } else {
        console.error(`${name} FAILED`);
        }
        return !!condition;
    }

    function openDB() {
        return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, VERSION);
        let needSeed = false;

        req.onupgradeneeded = (e) => {
            const db = req.result;
            if (!db.objectStoreNames.contains(STORE)) {
            db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
            }
            if (e.oldVersion === 0) needSeed = true; // first-time create
        };

        req.onsuccess = async () => {
            const db = req.result;

            if (needSeed) {
            let inserted = 0;
            while (inserted < TOTAL) {
                const tx = db.transaction(STORE, 'readwrite');
                const st = tx.objectStore(STORE);
                for (let i = 0; i < BATCH && inserted < TOTAL; i++, inserted++) {
                st.add(makeRecord());
                }
                await new Promise((res, rej) => {
                tx.oncomplete = res;
                tx.onerror = e => { console.error('TX error:', e.target.error); rej(e.target.error); };
                });
            }
            }

            resolve(db);
        };

        req.onerror = () => reject(req.error);
        });
    }

    const countAsync = (db) => new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readonly');
        const rq = tx.objectStore(STORE).count();
        rq.onsuccess = () => res(rq.result);
        rq.onerror   = () => rej(rq.error);
    });

    const firstNAsync = (db, n) => new Promise((res, rej) => {
        const out = [];
        const tx = db.transaction(STORE, 'readonly');
        const rq = tx.objectStore(STORE).openCursor();
        rq.onsuccess = e => {
        const cur = e.target.result;
        if (cur && out.length < n) { out.push(cur.value); cur.continue(); }
        else res(out);
        };
        rq.onerror = () => rej(rq.error);
    });

    const addAsync = (db, obj) => new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readwrite');
        const rq = tx.objectStore(STORE).add(obj);
        rq.onsuccess = () => res(rq.result);
        rq.onerror   = () => rej(rq.error);
    });

    const getAsync = (db, key) => new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readonly');
        const rq = tx.objectStore(STORE).get(key);
        rq.onsuccess = e => res(e.target.result);
        rq.onerror   = () => rej(rq.error);
    });

    const deleteAsync = (db, key) => new Promise((res, rej) => {
        const tx = db.transaction(STORE, 'readwrite');
        const rq = tx.objectStore(STORE).delete(key);
        rq.onsuccess = () => res(true);
        rq.onerror   = () => rej(rq.error);
    });

    const rand = (a,b) => a + Math.random()*(b-a);
    const randInt = (a,b) => Math.floor(rand(a,b+1));
    const randomArray = () =>
        Array.from({length: randInt(3,9)}, () => Number(rand(0,100).toFixed(2)));

    function makeRecord() {
        return {
        sensorReadings: randomArray(),
        cropPhoto: 'local.png',
        farmerNote: ['Irrigation OK','Fertilized','Pest check','All clear'][randInt(0,3)],
        gpsCoordinates: Number(rand(-90, 90).toFixed(6)),
        timestamp: new Date()
        };
    }

    /* Q1 */
    const db = await openDB();

    /* Q2 */
    const total = await countAsync(db);
    console.log('FarmData total:', total);

    const samples = await firstNAsync(db, 3);
    samples.forEach((rec, i) => {
        const ts = new Date(rec.timestamp);
        console.log(`Sample #${i+1}`);
        console.log('sensorReadings:', rec.sensorReadings, 'isArray =', Array.isArray(rec.sensorReadings));
        console.log('cropPhoto:', rec.cropPhoto, 'type =', typeof rec.cropPhoto);
        console.log('farmerNote:', rec.farmerNote, 'type =', typeof rec.farmerNote);
        console.log('gpsCoordinates:', rec.gpsCoordinates, 'type =', typeof rec.gpsCoordinates);
        console.log('timestamp:', ts.toISOString(), 'isDate =', ts instanceof Date && !Number.isNaN(ts.valueOf()));
    });


/* Q3 */
    console.log('Running IndexedDB unit tests…');

    function testLine(name, ok) {
    if (ok) {
        console.log(`%c${name} passed`, "color: green; font-weight:600");
    } else {
        console.error(`${name} FAILED`);
    }
    }

    const first = samples[0] || null;

    {
    const obj = {sensorReadings:[1,2], cropPhoto:'test.png', farmerNote:'UT',
                gpsCoordinates:0, timestamp:new Date()};
    const key = await addAsync(db, obj);
    const got = await getAsync(db, key);
    await deleteAsync(db, key);
    testLine("testAddAndGetRoundTrip", got && got.farmerNote === 'UT');
    }

    {
    const ok = first && typeof first.cropPhoto === "string" &&
                /\.(png|jpg|jpeg)$/i.test(first.cropPhoto);
    testLine("testImageExtension", ok);
    }

    {
    const ok = first && Array.isArray(first.sensorReadings);
    testLine("testSensorReadingsArray", ok);
    }

    {
    const ok = first && typeof first.gpsCoordinates === "number" &&
                first.gpsCoordinates >= -90 && first.gpsCoordinates <= 90;
    testLine("testGPSRange", ok);
    }

    {
    const ok = total >= 10000;
    testLine("testCountAfterBulkInsert", ok);
    }
    console.log("All tests finished");
})();
</script>
</body>
</html>
